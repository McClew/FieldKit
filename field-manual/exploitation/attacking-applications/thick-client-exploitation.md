---
icon: compact-disc
layout:
  width: default
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: false
  metadata:
    visible: true
---

# Thick Client Exploitation

## **Attacks**

### **Client Side attacks**

Although thick clients perform significant processing and data storage on the client side, they still communicate with servers for various tasks, such as data synchronisation or accessing shared resources. This interaction with servers and other external systems can expose thick clients to vulnerabilities similar to those found in web applications, including command injection, weak access control, and SQL injection.

Sensitive information like usernames and passwords, tokens, or strings for communication with other services, might be stored in the application's local files. Hardcoded credentials and other sensitive information can also be found in the application's source code, thus Static Analysis is a necessary step while testing the application. Using the proper tools, we can reverse-engineer and examine .NET and Java applications including EXE, DLL, JAR, CLASS, WAR, and other file formats. Dynamic analysis should also be performed in this step, as thick client applications store sensitive information in the memory as well.

| [Ghidra](https://www.ghidra-sre.org/)   | [IDA](https://hex-rays.com/ida-pro/) | [OllyDbg](http://www.ollydbg.de/)      | [Radare2](https://www.radare.org/r/index.html) |
| --------------------------------------- | ------------------------------------ | -------------------------------------- | ---------------------------------------------- |
| [dnSpy](https://github.com/dnSpy/dnSpy) | [x64dbg](https://x64dbg.com/)        | [JADX](https://github.com/skylot/jadx) | [Frida](https://frida.re/)                     |

### **Network Side Attacks**

If the application is communicating with a local or remote server, network traffic analysis will help us capture sensitive information that might be transferred through HTTP/HTTPS or TCP/UDP connection, and give us a better understanding of how that application is working. Penetration testers that are performing traffic analysis on thick client applications should be familiar with tools like:

| [Wireshark](https://www.wireshark.org/) | [tcpdump](https://www.tcpdump.org/) | [TCPView](https://learn.microsoft.com/en-us/sysinternals/downloads/tcpview) | [Burp Suite](https://portswigger.net/burp) |
| --------------------------------------- | ----------------------------------- | --------------------------------------------------------------------------- | ------------------------------------------ |

### **Server Side Attacks**

Server-side attacks in thick client applications are similar to web application attacks, and penetration testers should pay attention to the most common ones including most of the OWASP Top Ten.

## Initial Assessment and Analysis

1. Understand the Target:
   * Determine the File Type and Architecture: Use tools like `file` (on Linux/macOS) or PEiD (on Windows) to determine if it's an ELF (Linux executable), PE (Windows executable), script (Python, Perl, etc.), or another format. For executables, identify the architecture (e.g., x86, x64, ARM).
   * Identify the Language/Compiler: This helps choose the right disassembler/decompiler.
   * Check for Packaging or Obfuscation: See if the file is packed (e.g., UPX) or heavily obfuscated. If so, the first technical step is unpacking or de-obfuscating it.
2. Basic Triage (Strings and Imports):
   * Examine Strings: Use the `strings` utility (or similar functionality in a disassembler) to look for:
     * Hardcoded error messages, passwords, URLs, or API keys.
     * Function or variable names that might hint at the program's logic (e.g., `check_password`, `validate_license`).
   * Analyse Imports/Exports: For executables, check the imported libraries and functions (e.g., `kernel32.dll`, `libc.so`). This shows what system capabilities the program relies on (e.g., networking functions like `socket`, memory management functions like `memcpy`, or cryptography functions).

### Dynamic Analysis Setup (Your Existing Step)

3. Run and Observe (Dynamic Analysis):
   * ProcMon64 (Windows): As you noted, monitor file, registry, and process/thread activity. This is key for understanding side effects (e.g., where it writes log files, which registry keys it checks).
   * `ltrace`/`strace` (Linux): These tools monitor library calls (`ltrace`) or system calls (`strace`) made by the program. This can immediately show the flow of execution and which system resources are being accessed.
   * Network Monitoring: Use Wireshark or tcpdump if the program involves networking, to see the format of data sent and received.

### Static Analysis Setup

4. Load into a Disassembler/Decompiler:
   * Load the executable into a dedicated tool like IDA Pro, Ghidra, or radare2/Cutter.
   * Analyse the `main` function (or entry point): This is where you begin mapping the program's primary logic flow.
   * Identify key functions: Look for functions related to input handling (e.g., `read`, `scanf`, `gets`), memory operations (e.g., `malloc`, `memcpy`, `strcpy`), or security checks (e.g., password validation loops).

By following these steps, we move from a high-level overview to a detailed analysis, allowing us to quickly isolate areas of interest for potential vulnerabilities like buffer overflows, format string vulnerabilities, or logic flaws.

## Retrieving hardcoded Credentials

### File Recovery and Analysis

When a program deletes temporary files immediately after creating them, we need to employ techniques to prevent file deletion to capture and inspect them. By modifying the folder's security permissions to disallow deletion, we can force the application to leave the files behind. The process involves:

1. Right-clicking the target folder and navigating to Properties -> Security -> Advanced.
2. Disabling inheritance and converting permissions to explicit ones.
3. Editing the permissions for the relevant user or group to deselect the "Delete subfolders and files" and "Delete" checkboxes.

After changing the permissions and re-running the executable, we can inspect the dropped files. To retrieve these files, we must modify the program/script to remove the deletion commands and then execute it. This allows us to capture the files for further analysis.

### Static and Dynamic Analysis

Once we've recovered the files, we can perform both static and dynamic analysis.

* Static Analysis: Inspecting the code without executing it. We examine the program/script to understand its purpose. We can also use tools like Strings64.exe on the new executable to look for readable strings, which might reveal its nature, dependencies (like .NET Framework), or other clues.
* Dynamic Analysis: Executing the program and monitoring its behaviour. We can run the recovered program/script and observe its actions using ProcMon64. While the application's immediate behaviour might not be revealing, it's a crucial step.

### Deeper Code Analysis

When standard analysis doesn't yield clear results, we need to dig deeper into the application's memory and code structure.

1. Memory Inspection: Tools like x64dbg can be used to debug the running executable. By configuring the debugger to start at the application's exit breakpoint, we can avoid irrelevant library code. The key is to examine the memory maps for unusual regions, particularly those with read/write permissions and a type of "MAP." This type of region often indicates a memory-mapped file, which could contain another executable or hardcoded data. We can then dump this memory region to a file for further inspection.
2. Reverse Engineering: If the `strings` analysis of the dumped memory file reveals that it was a .NET executable. This is a critical finding because .NET binaries can be de-obfuscated and decompiled to reveal the original source code. We can use tools like De4Dot to remove obfuscation and then DnSpy to view the decompiled source code. This final step gives us the complete logic of the program, revealing its true purpose, such as hardcoded credentials for a service restart utility.
