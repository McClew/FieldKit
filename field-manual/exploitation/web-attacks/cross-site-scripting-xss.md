---
icon: xmark-large
layout:
  width: default
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: false
  metadata:
    visible: true
---

# Cross-Site Scripting (XSS)

Cross-site scripting (XSS) is a common vulnerability that allows attackers to inject malicious code into a website. Here's a quick summary of how it works and its potential impact:

**How XSS Works:** A typical web application sends code from a server to a user's browser. If a site doesn't properly check user input, an attacker can inject malicious JavaScript code into a field like a comment box. When another user views that page, their browser runs the malicious code without them knowing.

**Impact and Risk:** XSS attacks only affect the user's browser, not the back-end server. However, because they are so common, they pose a medium risk (low impact, but high probability). Therefore, it's crucial for developers to detect, fix, and prevent these vulnerabilities to protect users.

## Types of XSS

There are three main types of XSS vulnerabilities:

### **Stored (Persistent) XSS**

The most critical type of XSS, which occurs when user input is stored on the back-end database and then displayed upon retrieval (e.g., posts or comments).

### **Reflected (Non-Persistent) XSS**

Occurs when user input is displayed on the page after being processed by the backend server, but without being stored (e.g., search result or error message).

### **DOM-based XSS**

Another Non-Persistent XSS type that occurs when user input is directly shown in the browser and is completely processed on the client-side, without reaching the back-end server (e.g., through client-side HTTP parameters or anchor tags).

## XSS Testing Payloads

Test whether the page is vulnerable to XSS with the following basic XSS payload:

```html
<script>alert(window.origin)</script>
```

We use this payload as it is a very easy-to-spot method to know when our XSS payload has been successfully executed. Suppose the page allows any input and does not perform any sanitisation on it. In that case, the alert should pop up with the URL of the page it is being executed on, directly after we input our payload or when we refresh the page.

{% hint style="warning" %}
## Tip

Many modern web applications utilise cross-domain IFrames to handle user input, so that even if the web form is vulnerable to XSS, it would not be a vulnerability on the main web application.

This is why we are showing the value of `window.origin` in the alert box, instead of a static value like `1`. In this case, the alert box would reveal the URL it is being executed on, and will confirm which form is the vulnerable one, in case an IFrame was being used.
{% endhint %}

As some modern browsers may block the `alert()` JavaScript function in specific locations, it may be handy to know a few other basic XSS payloads to verify the existence of XSS.

One such XSS payload is `<plaintext>`, which will stop rendering the HTML code that comes after it and display it as plaintext. Another easy-to-spot payload is `<script>print()</script>` that will pop up the browser print dialogue, which is unlikely to be blocked by any browsers.

To see whether the payload is persistent and stored on the back-end, we can refresh the page and see whether we get the alert again. If we do, we would see that we keep getting the alert even throughout page refreshes, confirming that this is indeed a `Stored/Persistent XSS` vulnerability.

## Automated Discovery

Almost all Web Application Vulnerability Scanners (like [Nessus](https://www.tenable.com/products/nessus), [Burp Pro](https://portswigger.net/burp/pro), or [ZAP](https://www.zaproxy.org/)) have various capabilities for detecting all three types of XSS vulnerabilities. These scanners usually do two types of scanning: A **Passive Scan**, which reviews client-side code for potential DOM-based vulnerabilities, and an **Active Scan**, which sends various types of payloads to attempt to trigger an XSS through payload injection in the page source.

While paid tools usually have a higher level of accuracy in detecting XSS vulnerabilities (especially when security bypasses are required), we can still find open-source tools that can assist us in identifying potential XSS vulnerabilities.

Such tools usually work by identifying input fields in web pages, sending various types of XSS payloads, and then comparing the rendered page source to see if the same payload can be found in it, which may indicate a successful XSS injection. Still, this will not always be accurate, as sometimes, even if the same payload was injected, it might not lead to a successful execution due to various reasons, so we must always manually verify the XSS injection.

Some of the common open-source tools that can assist us in XSS discovery are [XSS Strike](https://github.com/s0md3v/XSStrike), [Brute XSS](https://github.com/rajeshmajumdar/BruteXSS), and [XSSer](https://github.com/epsylon/xsser).

### XSS Strike

Run the script and provide it a URL with a parameter using `-u`.

```bash
clue@machine[~]$ python xsstrike.py -u "http://SERVER_IP:PORT/index.php?task=test" 

        XSStrike v3.1.4

[~] Checking for DOM vulnerabilities 
[+] WAF Status: Offline 
[!] Testing parameter: task 
[!] Reflections found: 1 
[~] Analysing reflections 
[~] Generating payloads 
[!] Payloads generated: 3072 
------------------------------------------------------------
[+] Payload: <HtMl%09onPoIntERENTER+=+confirm()> 
[!] Efficiency: 100 
[!] Confidence: 10 
[?] Would you like to continue scanning? [y/N]
```

In this example, the tool identified the parameter as vulnerable to XSS from the first payload.

## Manual Discovery

The most basic method of looking for XSS vulnerabilities is manually testing various XSS payloads against an input field in a given web page. We can find huge lists of XSS payloads online, like the one on [PayloadAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md) or the one in [PayloadBox](https://github.com/payloadbox/xss-payload-list). We can then begin testing these payloads one by one by copying each one and adding it in our form, and seeing whether an alert box pops up.

{% hint style="info" %}
## Note

XSS can be injected into any input in the HTML page, which is not exclusive to HTML input fields, but may also be in HTTP headers like the Cookie or User-Agent (i.e., when their values are displayed on the page).
{% endhint %}

### Blind XSS Detection

A Blind XSS vulnerability occurs when the vulnerability is triggered on a page we don't have access to.

Blind XSS vulnerabilities usually occur with forms only accessible by certain users (e.g., Admins). Some potential examples include:

* Contact Forms
* Reviews
* User Details
* Support Tickets
* HTTP User-Agent header

## DOM Attacks

### Source & Sink

To further understand the nature of the DOM-based XSS vulnerability, we must understand the concept of the `Source` and `Sink` of the object displayed on the page. The `Source` is the JavaScript object that takes the user input, and it can be any input parameter like a URL parameter or an input field, as we saw above.

On the other hand, the `Sink` is the function that writes the user input to a DOM Object on the page. If the `Sink` function does not properly sanitise the user input, it would be vulnerable to an XSS attack. Some of the commonly used JavaScript functions to write to DOM objects are:

* `document.write()`
* `DOM.innerHTML`
* `DOM.outerHTML`

Furthermore, some of the `jQuery` library functions that write to DOM objects are:

* `add()`
* `after()`
* `append()`

If a `Sink` function writes the exact input without any sanitisation (like the above functions), and no other means of sanitisation were used, then we know that the page should be vulnerable to XSS.

### Payload

The `innerHTML` function does not allow the use of the `<script>` tags within it as a security feature. Still, there are many other XSS payloads we use that do not contain `<script>` tags, like the following XSS payload:

```html
<img src="" onerror=alert(window.origin)>
```

To target a user with this DOM XSS vulnerability, we can copy the URL from the browser and share it with them, and once they visit it, the JavaScript code should execute. This payload is among the most basic.

## Session Hijacking

